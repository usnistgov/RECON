/* VocBase.java
 * routines to preload special vocabulary terms for RECON
 * these terms are recognized, and some uses are automatically generated
 * 
 * @author Ed Barkmeyer, NIST, September, 2013
 * (extracted from VocKey to split dictionary and vocabulary construction)
 */
package core;

import NBVR.Vocabulary.*;

import java.util.ArrayList;

import utilities.StringArrayReader;

/** VocBase
 *  VocBase initializes the Vocabulary with the predefined terms
 *  used in the grammar and/or generated by the parse and rewrite operations.
 *  
 *  The class has no instances.  It is merely a collector for static methods.
 */
public class VocBase {

	/* the Vocabulary factory class */
	private static final VocabularyFactory theVocFactory = VocabularyFactory.eINSTANCE;

	/* special vocabulary entries */
	public static VocNoun vocThing;	/* the supertype of all nouns */
	public static VocNoun vocQuantity;	/* the type of all quantity values */
	public static VocNoun vocCollection;	/* the type of all collections */
	public static VocVerb vocIs;	/* the verb is: subject (thing) is object (thing) */
	public static VocVerb vocHas;	/* the verb has: subject (thing) has property */
	public static VocVerb vocEqual;	/* the verb equals */
	public static VocVerb vocLE;	/* the verb 'is less or equal' */
	public static VocVerb vocLT;	/* the verb 'is less than' */
	public static VocVerb vocHasMember;	/* the fake verb 'hasMember' */
	public static VocVerb vocHasTheme; /* the fake verb 'hasTheme' */
	public static VocProperty vocHasCount;	/* the property 'count of' */
	public static VocProperty vocHasQuantity;	/* the property 'quantity of' */

	/* vocabulary items that have special meaning to the RECON tool
	 * and are used in structures generated by the tool itself
	 */
	public static String specials[] = {
		"T thing",
		"W t1", "W t2",					// define symbols, silence objections 
		"V (thing: t1) is (thing: t2)",	// the basic 'is' VocVerb
		"F (t1) is the same as (t2)",
		"V (thing: t1) has (thing: t2)",	// the basic 'has' VocVerb
		
		"T quantity",
		"W q1", "W q2",					// define symbols
		"V (quantity:q1) equals (quantity:q2)", 	// quantity comparisons
		"F (q1) is equal () to (q2)",
		"V (quantity:q1) is less than (quantity:q2)",
		"F (q1) is fewer than (q2)",
		"F (q2) is greater than (q1)",
		"F (q2) is more than (q1)",
		"V (quantity:q1) is less or equal (quantity:q2)",
		"F (q1) is less than or equal to (q2)",
		"F (q1) is at most (q2)",
		"F (q2) is greater than or equal to (q1)",
		"F (q2) is greater or equal (q1)",
		"F (q2) is at least (q1)",

		"P (quantity) is the quantity () of (thing)", // the quantity property

		"T collection",
		"T number",
		"P (number) is the count () of (collection)", // the count property
		"V (collection) hasMember (thing)", // fake member verb
		
		"V (thing) hasTheme (thing)"	// fake event description verb

	};

	/* working word list for term lookups */
	private static ArrayList<Word> term = new ArrayList<Word>(5);
	
	/** initVocabulary()
	 *   this is the public entry point
	 *   
	 *  preload the Terminology (Vocabulary) with the noun and verb terms 
	 *  that have special meaning to parse and rewrite
	 *  
	 *  some terms are created directly below
	 *  others are loaded by script, using VocLoad
	 *  The 'specials' array contains the declarations script.
	 *  
	 *  initVocabulary should not be called until the Dictionary 
	 *  has been loaded.
	 *  
	 *  @param voc = the Terminology object that is the merged Vocabulary
	 */
	static public void initVocabulary(Terminology voc)
	{

		/* add the fake verbs 'hasMember' and 'hasTheme' to the Dictionary */
		Adjunct hasMemberVerb = theVocFactory.createAdjunct(theVocFactory.makeWordForm("hasMember"));
		Adjunct hasThemeVerb = theVocFactory.createAdjunct(theVocFactory.makeWordForm("hasTheme"));
		
		/* Now, make vocabulary items for the base concepts
		 * use VocLoad to process the vocabulary script */
		new VocLoad(new StringArrayReader(specials), "(preload)", null, VocLoad.VOCABULARY_MODE);
		
		/* Then, find and remember the entries that are generated */
		vocThing = lookupNoun(VocKey.thingNoun);
		vocQuantity = lookupNoun(VocKey.quantityNoun);
		vocCollection = lookupNoun(VocKey.collectionNoun);
		
		/* now find the special Verb entries: be, have */
		vocIs = lookupVerb(VocKey.isVerb, vocThing);
		vocHas = lookupVerb(VocKey.hasVerb, vocThing);
		
		/* the weird entry for collection membership */
		vocHasMember = lookupVerb(hasMemberVerb, vocCollection);
		vocHasTheme = lookupVerb(hasThemeVerb, vocThing);
		
		/* find the basic properties for quantities */
		vocHasQuantity = lookupProperty(VocKey.quantityNoun, vocThing);
		vocHasCount = lookupProperty(VocKey.countNoun, vocCollection);

		/* the verbs for quantity comparisons */
		vocEqual = lookupVerb(VocKey.equalsVerb, vocQuantity);
		term.clear();
		term.add(VocKey.isVerb);
		term.add(findWord("less"));
		term.add(findWord("than"));
		vocLT = (VocVerb)VocLoad.findVocItem(term, VocItemKind.VERB_CONCEPT, vocQuantity);
		term.clear();
		term.add(VocKey.isVerb);
		term.add(findWord("less"));
		term.add(findWord("or"));
		term.add(VocKey.equalsVerb);
		vocLE = (VocVerb)VocLoad.findVocItem(term, VocItemKind.VERB_CONCEPT, vocQuantity);

	}
	
	/** findWord(string)
	 * finds or creates the dictionary Word that matches the given string
	 * @param word = the string representation of the word
	 * @return the Dictionary Word whose base is the WordForm that is the string
	 */
	private static Word findWord(String word)
	{
		return theVocFactory.makeWordForm(word).getWord();
	}

	/** lookupNoun(word)
	 * find the VocabularyItem (VocNoun) that matches the Term 
	 * that consists of the single Word given
	 * @param noun = the single Word that is the term for the VocNoun
	 * @return the matching VocNoun, or null
	 */
	private static VocNoun lookupNoun(Word noun)
	{
		term.clear();
		term.add(noun);
		return (VocNoun)VocLoad.findVocItem(term, VocItemKind.NOUN_CONCEPT, null);
	}
	
	/** lookupVerb(word)
	 * find the Vocabulary item (VocVerb) that matches the verb Term 
	 * that consists of the single Word given
	 * @param noun = the single Word that is the term for the VocVerb
	 * @return the matching VocNoun, or null
	 */
	private static VocVerb lookupVerb(Word verb, VocNoun context)
	{
		term.clear();
		term.add(verb);
		return (VocVerb)VocLoad.findVocItem(term, VocItemKind.VERB_CONCEPT, context);
	}

	/** lookupProperty()
	 * find the Vocabulary Property that matches the Property Term
	 * that consists of the single Word given
	 *   and the context is the given domain of the property
	 * @param property = the single Word that names the property
	 * @param domain = the VocNoun that is the domain that has the property
	 * @return the matching VocProperty, or null
	 */
	private static VocProperty lookupProperty(Word property, VocNoun domain)
	{
		term.clear();
		term.add(property);
		return (VocProperty)VocLoad.findVocItem(term, VocItemKind.PROPERTY_CONCEPT, domain);
	}



}
